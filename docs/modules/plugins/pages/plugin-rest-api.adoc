= REST API Plugin

The plugin provides the following abilities:

* build and send HTTP requests
* validate HTTP responses (headers, status code, body)
* validate JSON content of HTTP response bodies

== Installation

.build.gradle
[source,gradle,subs="attributes+"]
----
implementation(group: 'org.vividus', name: 'vividus-plugin-rest-api', version: '{current-version}')
----


== Properties

NOTE: The properties marked with *bold* are mandatory.

[cols="3,1,1,3", options="header"]
|===
|Property Name
|Acceptable values
|Default
|Description

4+^.^|_Configuration of HTTP retries on service unavailability_

|`http.service-unavailable-retry.max-retries`
|`1`
|`integer`
|The maximum number of allowed retries if the server responds with a HTTP code from the retry code set defined below

|`http.service-unavailable-retry.status-codes`
|<empty>
|set of integers
|The set of HTTP status codes to be retried. If it's empty, no retries will be performed

|`http.service-unavailable-retry.retry-interval`
|`PT1S`
|{iso-date-format-link}
|The retry interval between subsequent requests

|===

== Expressions

NOTE: The expression parameters marked with *bold* are mandatory.

=== `encodeUriXyz`

`#{encodeUriXyz(..)}` is a family of expressions that encode specific URI components (e.g. path, query)
by percent encoding illegal characters, which includes non-US-ASCII characters, and also characters that
are otherwise illegal within the given URI component type, as defined in
https://www.ietf.org/rfc/rfc3986.txt[RFC 3986].

[cols="3,2", options="header", subs="+quotes"]
|===
|Syntax
|Description

|`#{encodeUriUserInfo(*$userInfo*)}`
|encodes the given URI user info

|`#{encodeUriHost(*$host*)}`
|encodes the given URI host

|`#{encodeUriPath(*$path*)}`
|encodes the given URI path

|`#{encodeUriPathSegment(*$segment*)}`
|encodes the given URI path segment

|`#{encodeUriQuery(*$query*)}`
|encodes the given URI query

|`#{encodeUriQueryParameter(*$queryParameter*)}`
|encodes the given URI query parameter

|`#{encodeUriFragment(*$fragment*)}`
|encode the given URI fragment
|===

.Examples of the expressions encoding URI parts
|===
|Expression |Result

|`#{encodeUriUserInfo(user@vividus.dev:pass)}`
|user%40vividus.dev:pass

|`#{encodeUriHost(vividus.бел)}`
|vividus.%D0%B1%D0%B5%D0%BB

|`#{encodeUriPath(/path/with spaces/)}`
|/path/with%20spaces/

|`#{encodeUriPathSegment(path/segment)}`
|path%2Fsegment

|`#{encodeUriQuery(a&b=c d)}`
|a&b=c%20d

|`#{encodeUriQueryParameter(a&b)}`
|a%26b

|`#{encodeUriFragment(frag ment)}`
|frag%20ment

|===

== Steps

=== Init multipart HTTP request

Sets https://tools.ietf.org/html/rfc7578[multipart] request entity that will be used while executing HTTP requests.

[source,gherkin]
----
Given multipart request:$requestParts
----

where `requestParts` - `ExamplesTable` representing the list of the request parts with the following columns:

* `type` - one of request part types: `STRING`, `FILE`, `BINARY`
* `name` - the request part name
* `value` - the path to the resource with the content for `FILE` part type and the actual content for `STRING` and `BINARY` part types
* `contentType` - https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type[the content type]
* `fileName` - the name of the file contained in this request part. The parameter is not allowed for `STRING` part type, but it's required for `BINARY` one and optional for `FILE` part type

.Init HTTP request consisting of 4 different parts
[source,gherkin]
----
Given multipart request:
|type  |name      |value         |contentType|fileName       |
|file  |file-key  |/data/file.txt|           |anotherName.txt|
|file  |file-key2 |/data/file.txt|text/plain |               |
|string|string-key|string1       |text/plain |               |
|binary|binary-key|raw           |text/plain |raw.txt        |
----

=== Add HTTP headers to the request

Adds https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields[HTTP headers] to the HTTP request.

[source,gherkin]
----
When I add request headers:$headers
----

* `headers` - `ExamplesTable` representing the list of the headers with columns `name` and `value` specifying HTTP header

.Add request header with name Accept-Language and value en-ru
[source,gherkin]
----
When I add request headers:
|name           |value |
|Accept-Language|en-ru |
When I send HTTP GET to the relative URL '/get?name=Content'
Then a JSON element by the JSON path '$.headers.Accept-Language' is equal to '"en-ru"'
----

=== Wait for JSON element in the HTTP response

Executes the provided sub-steps until the HTTP response body contains an element by the specified JSON path or the maximum number of retries is reached. The maximum duration of the step execution is not limited. The actions of the step:

. execute sub-steps
. wait the polling interval
. if the required JSON element exists or the maximum number of retries is reached, then the execution stops, otherwise the step actions are repeated

[source,gherkin]
----
When I wait for presence of element by `$jsonPath` with `$pollingInterval` polling interval retrying $retryTimes times$stepsToExecute
----

* `jsonPath` - the JSON path of the element to find
* `pollingInterval` - the duration to wait between retries
* `retryTimes` - the maximum number of the retries
* `stepsToExecute` - the sub-steps to execute at each iteration

.Wait for presence of element by JSON path $.data.testData
[source,gherkin]
----
When I wait for presence of element by `$.data.testData` with `PT5S` polling interval retrying 10 times
|step                                  |
|When I set request headers:           |
|{headerSeparator=!,valueSeparator=!}  |
|!name          !value                !|
|!Authorization !${accessToken}       !|
|When I issue a HTTP GET request for a resource with the URL '${requestUrl}'|
----

=== Validate secure protocols supported by server

Checks that a server defined by the `hostname` supports secure protocols listed in the `protocols` parameter.

[source,gherkin]
----
Then server `$hostname` supports secure protocols that $rule `$protocols`
----

* `$hostname` - the server hostname
* `$rule` - xref:parameters:collection-comparison-rule.adoc[the collection comparison rule]
* `$protocols` - the secure protocols that are expected to match specified `$rule`

.Validate the server supports TLSv1.2 and TLSv1.3 protocols
[source,gherkin]
----
Then server `vividus-test-site.herokuapp.com` supports secure protocols that contain `TLSv1.2,TLSv1.3`
----
